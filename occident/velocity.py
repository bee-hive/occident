import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import sem
import os

def calculate_centroids_for_all_cells(frame, unique_cell_ids):
    """
    Calculate the centroids of all cells in a given frame.

    Parameters
    ----------
    frame : np.ndarray
        A 2D numpy array representing a frame of cell data, where each unique non-zero integer represents a distinct cell.
    unique_cell_ids : np.ndarray
        A 1D numpy array containing the unique cell IDs in the frame.

    Returns
    -------
    dict
        A dictionary containing the centroids of all cells, where each key is a cell ID and each value is a tuple of the x and y coordinates of the centroid.
    """
    centroids = {}
    for cell_id in unique_cell_ids:
        y, x = np.where(frame == cell_id)
        if len(x) > 0 and len(y) > 0:
            centroids[cell_id] = (np.mean(x), np.mean(y))
        else:
            centroids[cell_id] = None
    return centroids

def calculate_velocity_consecutive_frames(
        cell_array,
        time_between_frames,
        filename
):
    """
    Calculate the velocity of all cells in a given frame by comparing the centroids of the cells between consecutive frames.

    Parameters
    ----------
    cell_array : np.ndarray
        A 3D numpy array representing a stack of cell data, where each unique non-zero integer represents a distinct cell.
    time_between_frames : int
        The time in seconds between each frame. This value is set to 1 when we wish to keep in units of frames (not seconds).
    filename : str
        The filename of the data, used for bookkeeping in the output DataFrame.

    Returns
    -------
    pd.DataFrame
        A pd DataFrame containing the velocity of all cells, where each row is a cell and each column is a frame.
    """
    n_frames = cell_array.shape[0]
    unique_cell_ids = np.unique(cell_array[cell_array != 0])  # Exclude background ID

    df_velocity = pd.DataFrame(unique_cell_ids, columns=['cell_id'])
    velocities = {}

    for frame_index in range(1, n_frames):  # Start from frame index 1 (not 0) to compare with t-1
        if frame_index == 1 or frame_index % 10 == 0:
            print(f"Processing Frame: {frame_index} out of {n_frames}")
        column_name = f'v_frame_{frame_index-1}_to_{frame_index}'
        velocities[column_name] = np.nan * np.ones(len(unique_cell_ids))  # Initialize column with NaNs

        centroids_t = calculate_centroids_for_all_cells(cell_array[frame_index, :, :], unique_cell_ids)
        centroids_t_minus_1 = calculate_centroids_for_all_cells(cell_array[frame_index - 1, :, :], unique_cell_ids)

        for cell_id in unique_cell_ids:
            centroid_t = centroids_t.get(cell_id)
            centroid_t_minus_1 = centroids_t_minus_1.get(cell_id)

            if centroid_t is None or centroid_t_minus_1 is None:
                continue  # Skip if centroids can't be calculated

            displacement = np.linalg.norm(np.array(centroid_t) - np.array(centroid_t_minus_1))
            velocity = displacement / time_between_frames
            
            cell_index = df_velocity[df_velocity['cell_id'] == cell_id].index.item()
            velocities[column_name][cell_index] = velocity

    # Add velocities to the DataFrame
    for key, value in velocities.items():
        df_velocity[key] = value
    df_velocity['filename'] = filename.replace('.zip', '')

    return df_velocity

def transform_velocity_df(
        velocity_dict, 
        transformed_dict,
        max_velocity_value
):
    """
    Transform the velocity DataFrame generated by calculate_velocity_consecutive_frames into a long format.

    Parameters
    ----------
    velocity_dict : dict
        A dictionary where the keys are the experiment names and the values are DataFrames containing the velocity data.
    transformed_dict : dict
        A dictionary where the transformed DataFrames will be stored.
    max_velocity_value : int or None
        The maximum velocity to include in the transformed DataFrame. If None, all velocities will be included.

    Returns
    -------
    dict
        The transformed_dict parameter with the transformed DataFrames.

    Notes
    -----
    The transformed DataFrame will have the following columns:
    * cell_id: The ID of the cell.
    * filename: The filename of the data.
    * frame: The frame number of the velocity measurement.
    * velocity: The velocity measurement.
    """
    for key, df in velocity_dict.items():
        # Melt the DataFrame
        melted_df = pd.melt(df, id_vars=['cell_id', 'filename'], var_name='frame', value_name='velocity',
                            value_vars=[col for col in df.columns if col.startswith('v_frame_')])
        # Remove rows where 'velocity' is NaN and >= max_velocity_value
        filtered_df = melted_df.dropna(subset=['velocity']).copy()
        if max_velocity_value is not None:
            filtered_df = filtered_df[filtered_df['velocity'] < max_velocity_value]
        # Reset index
        filtered_df.reset_index(drop=True, inplace=True)
        # Adjust the 'frame' column to be an integer by extracting the first number in the naming pattern
        filtered_df['frame'] = filtered_df['frame'].str.extract(r'(\d+)_to_').astype(int)
        # Sort by 'cell_id' and 'frame'
        filtered_df.sort_values(by=['frame', 'cell_id'], inplace=True)
        # Store the transformed DataFrame in the new dictionary
        transformed_dict[key] = filtered_df
    return transformed_dict

def safe_sem(x):
    """
    Calculate the standard error of the mean (SEM) of an array, returning NaN if there is not enough data.

    Parameters
    ----------
    x : array_like
        The array to calculate the SEM of.

    Returns
    -------
    scalar or NaN
        The SEM of the array, or NaN if there is not enough data.
    """
    return sem(x) if len(x) > 1 else np.NaN  # Return NaN if not enough data

def make_velocity_plot(
        group_type,
        title_prefix,
        combined_mask_dict, 
        plot_group_colors, 
        plot_name,
        task_timestamp,
        save_plot_path
):
    """
    Create a plot of mean velocity across frames for each group of cells in a experiment.

    Parameters
    ----------
    group_type : str
        The type of grouping to do. Either 'individual' or 'combined'.
    title_prefix : str
        The beginning of the title for the plot.
    combined_mask_dict : dict
        A dictionary where the keys are group names and the values are DataFrames of cell tracks.
    plot_group_colors : list
        A list of colors to use for each group.
    plot_name : str
        The base name of the file to save the plot to.
    task_timestamp : str
        The timestamp of the task when the plot was generated.
    save_plot_path : str
        The directory to save the plot to.
    """
    plt.figure(figsize=(14, 7))
    color_iter = iter(plot_group_colors)  # Create an iterator over the colors list

    if group_type == 'individual':
        print(f"Grouping by individual frame")
        for group_name, df_for_plot in combined_mask_dict.items():

            print(f"Processing: {group_name}")
            # Calculate mean velocity for every individual frame
            mean_velocity_per_frame = df_for_plot.groupby('frame')['velocity'].mean()
            
            # Calculate SEM for velocity for every individual frame
            sem_velocity_per_frame = df_for_plot.groupby('frame')['velocity'].apply(safe_sem)

            # Get the next color from the iterator
            color = next(color_iter, 'gray')  # Default to 'gray' if the colors list is exhausted

            # Plot the mean velocity per frame with a line
            plt.plot(mean_velocity_per_frame.index, mean_velocity_per_frame, lw=2, color=color, label=f'{group_name} Mean Velocity')

            # Add the error area for SEM
            plt.fill_between(mean_velocity_per_frame.index, mean_velocity_per_frame - sem_velocity_per_frame, 
                            mean_velocity_per_frame + sem_velocity_per_frame, color=color, alpha=0.2, label=f'{group_name} Error')

        plt.title(f'{title_prefix}: Mean Velocity per Frame')
        plt.xlabel('Frame')
        plt.ylabel('Mean Velocity')
        plt.grid(True)
        plt.legend(loc='upper left', bbox_to_anchor=(1,1))
        plt.tight_layout()

        plot_path_name = os.path.join(save_plot_path, f"{plot_name}_{group_type}_{task_timestamp}.pdf")

        plt.savefig(plot_path_name)
        plt.close()  # Close the figure to free memory
        print(f"Plot saved: {plot_path_name}")
    if group_type == 'combined':
        print(f"Grouping by frame group")
        for group_name, df_for_plot in combined_mask_dict.items():
            print(f"Processing: {group_name}")
            # Create a 'frame group' column for grouping frames into sets of 50
            df_for_plot['frame_group'] = df_for_plot['frame'] // 50

            # Calculate mean velocity for every 'frame group'
            mean_velocity_per_frame_group = df_for_plot.groupby('frame_group')['velocity'].mean()
            
            # Calculate SEM for velocity for every 'frame group'
            sem_velocity_per_frame_group = df_for_plot.groupby('frame_group')['velocity'].apply(lambda x: sem(x) if len(x) > 1 else np.NaN)

            # Get the next color from the iterator
            color = next(color_iter, 'gray')  # Default to 'gray' if the colors list is exhausted

            # Plot the mean velocity per 'frame group' with a line
            plt.plot(mean_velocity_per_frame_group.index * 50, mean_velocity_per_frame_group, lw=2, color=color, label=f'{group_name} Mean Velocity')

            # Add the error area for SEM
            plt.fill_between(mean_velocity_per_frame_group.index * 50, mean_velocity_per_frame_group - sem_velocity_per_frame_group, 
                            mean_velocity_per_frame_group + sem_velocity_per_frame_group, color=color, alpha=0.2, label=f'{group_name} Error')

        plt.title(f'{title_prefix}: Mean Velocity per Frame Group')
        plt.xlabel('Frame Group Start')
        plt.ylabel('Mean Velocity')
        plt.grid(True)
        plt.legend(loc='upper left', bbox_to_anchor=(1,1))
        plt.tight_layout()

        plot_path_name = os.path.join(save_plot_path, f"{plot_name}_{group_type}_{task_timestamp}.pdf")

        plt.savefig(plot_path_name)
        plt.close()  # Close the figure to free memory
        print(f"Plot saved: {plot_path_name}")

def make_violin_plot(
        combined_mask_dict,
        mask_name,
        plot_name,
        task_timestamp,
        save_plot_path_violin
):
    """
    Creates a violin plot of the velocity distribution across all groups in the given combined_mask_dict.

    Parameters
    ----------
    combined_mask_dict : dict
        A dictionary where the keys are group names and the values are DataFrames containing the data for that group.
    mask_name : str
        The name of the mask to be used in the plot title.
    plot_name : str
        The name of the plot to be saved.
    task_timestamp : str
        The timestamp of the task to be used in the plot filename.
    save_plot_path_violin : str
        The path to the directory where the plot should be saved.
    """
    # Create an empty DataFrame
    all_data = pd.DataFrame()
    
    # Append all groups data into one DataFrame and add a 'Group' column
    for group_name, df in combined_mask_dict.items():
        df['Group'] = group_name
        all_data = pd.concat([all_data, df], ignore_index=True)

    # Setup the figure
    fig, ax = plt.subplots(figsize=(10, 6))
    
    # Creating violin plot on the specified Axes
    sns.violinplot(ax=ax, x='Group', y='velocity', data=all_data)
    
    mask_name_title = mask_name.title().replace('_', ' ')
    ax.set_title(f'Velocity Distribution Across Groups - {mask_name_title}')
    ax.set_xlabel('Group')
    ax.set_ylabel('Velocity')
    
    plt.tight_layout()
    
    plot_path_name = os.path.join(save_plot_path_violin, f"{plot_name}_{task_timestamp}.pdf")
    
    plt.savefig(plot_path_name)
    plt.close(fig)  # Close the figure to free memory
    print(f"Plot saved: {plot_path_name}")